<head>
    <meta http-equiv='Content-Type' content="text/html; charset=utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
    <title>Яндекс.Почта и скорость загрузки</title>
</head>
<body>
<header>
    Блог компании Яндекс.Яндекс
</header>
<article>
    <h1>ЯНДЕКС.ПОЧТА: КАК МЫ ИЗМЕРЯЕМ СКОРОСТЬ ЗАГРУЗКИ И УЛУЧШАЕМ ЕЁ</h1>
    <p> Если ваш сайт медленно грузится, вы рискуете тем, что люди не оценят ни то,<br>
		какой он красивый, ни то, какой он удобный. Никому не понравится, когда <br>
		тормозит. Мы регулярно добавляем в Яндекс.Почту новую функциональность,<br>
		иногда — исправляем ошибки, а это значит, у нас постоянно появляются новый код<br>
		и новая логика. Всё это напрямую влияет на скорость работы интерфейса.<br></p>
	<article>
	<h2>Что мы измеряем</h2>
	<p><h3>Этапы первой загрузки</h3>
		<ul>
			<li>подготовка;</li>
			<li>загрузка статики (HTTP-запрос и парсинг);</li>
			<li>исполнение модулей;</li>
			<li>инициализация базовых объектов;</li>
			<li>отрисовка.</li>
		</ul></p>
	<p><h3>Этапы отрисовки любой страницы</h3>
		<ul>
			<li>подготовка к запросу на сервер;</li>
			<li>запрос данных с сервера;</li>
			<li>шаблонизация</li>
			<li>обновление DOM.</li>
		</ul></p>
</article>
	<article>
		<p><q>Ок, теперь у нас есть метрики, мы можем отправить их на сервер</q> - говорим мы/</p>
		<p><q>Что же дальше?</q> - вопрошаете вы</p>
		<p><q>А давай построим график!</q> - отвечаем мы</p>
		<p><q>А что будем считать?</q> - уточняете вы</p>
	</article>
	<article>
		<p> Как вы знаете, медиана – это серединное, а не среднее значение в выборке.<br>
			Если у нас имеются числа 1, 2, 2, 3, 8, 10, 20, то медиана – 3, а среднее – 6,5.<br>
			В общем случае медиана отлично показывает, сколько грузится средний пользователь.<br></p>

		<p> В случае ускорения или замедления медиана, конечно, изменится. Но она не может<br>
			рассказать, сколько пользователей ускорилось, а сколько замедлилось.<br></p>

		<p> <abbr title="Application Performance Index">APDEX</abbr> – метрика, которая сразу говорит: хорошо или плохо. Метрика<br>
			работает очень просто. Мы выбираем временной интервал [0; t], такой, что если<br>
			время показа страницы попало в него, то пользователь счастлив. Берем еще один<br>
			интервал, (t; 4t] (в четыре раза больше первого), и считаем, что если страница<br>
			показана за это время, то пользователь в целом удовлетворен скоростью работы,<br>
			но уже не настолько счастлив. И применяем формулу:<br>

			<div> (кол-во счастливых пользователей + кол-во удовлетворенных / 2) / (кол-во всех).<br>
			Получается значение от нуля до единицы, которое, видимо, лучше всего показывает,<br>
			хорошо или плохо работает почта.</div></p>
	</article>
</article>
<article>
<h2>Как мы измеряем</h2>

<p>Сейчас модуль обновления сам логирует все свои стадии, и можно легко понять<br>
причину замедления: медленнее стал отвечать сервер либо слишком долго<br>
выполняется JavaScript. Выглядит это примерно так:</p>

<code>this.timings['look-ma-im-start'] = Date.now();<br>
this.timings['look-ma-finish'] = Date.now();</code>

<p>C помощью Date.now() мы получаем текущее время. Все тайминги собираются и при<br>
отправке рассчитываются. На этапах разница между “end” и “start” не считается,<br>
а все вычисления производятся в конце:<br></p>

<code> var totalTime = this.timings['look-ma-finish'] - this.timings['look-ma-im-start'];</code>

<p>И на сервер прилетают подобные записи:</p>

<code>serverResponse=50&domUpdate=60</code>
</article>
<article>
		<h2>Как мы ускоряем</h2>

		<p>Чтобы снизить время загрузки почты при выходе новых версий,
		мы уже делаем следующее:</p>
		<ul>
		<li>включаем gzip;</li>
		<li>выставляем заголовки кэширования;</li>
		<li>фризим CSS, JS, шаблоны и картинки;</li>
		<li>используем CDN;</li>
		</ul>

		<p>Мы подумали: «А что если хранить где-то старую версию файлов, а при выходе новой<br>
		передавать только diff между ней и той, которая сохранена у пользователя?»<br>
		В браузере же останется просто наложить патч на клиенте.</p>

		<p>На самое деле эта идея не нова. Уже существуют стандарты для HTTP — например,<br>
		RFC 3229 «Delta encoding in HTTP» и «Google SDHC», — но по разным причинам они<br>
		не получили должного распространения в браузерах и на серверах.</p>

		<p>Мы же решили сделать свой аналог на JS. Чтобы реализовать этот метод обновления,<br>
		начали искать реализации diff на JS. На популярных хостингах кода нашли<br>
		библиотеки:<p>
		<ul>
		<li>VCDiff</li>
		<li>google-diff-patch-match</li>
		</ul>
		
		<p>Для окончательного выбора библиотеки нам нужно сравнить:</p>
		<table>
	<thead>
		<tr>
			<th>Библиотека</th>
			<th>IE 9</th>
			<th>Opera 12</th>
		</tr>
	<tbody>
		<tr>
			<th>vcdiff</th>
			<th>8</th>
			<th>5</th>
		</tr>
		<tr>
			<th>google diff</th>
			<th>1363</th>
			<th>76</th>
		</tr>
	</tbody>
	<thead>
</table>


<p>После того как мы определились с библиотекой для диффа, нужно определиться с тем,<br>
где и как хранить статику на клиенте.</p>

<p>Формат файла с патчами для проекта выглядит так:</p>
<code>[
    {<br>
        "k": "jane.css",<br>
        "p": [patch],<br>
        "s": 4554<br>
    },<br>
    {<br>
        "k": "jane.css",<br>
        "p": [patch],<br>
        "s": 4554<br>
    }<br>
]</code>

	<p>То есть это обычный массив из объектов. Каждый объект — отдельный ресурс. У<br>
	каждого объекта есть три свойства. k — названия ключа в localStorage для этого<br>
	ресурса. p — патч для ресурса, который сгенерировал vcdiff. s — чексумма для<br>
	ресурса актуальной версии, чтобы потом можно было проверить правильность<br>
	наложения патча на клиенте. Чексумма вычисляется по алгоритму Флетчера.<p>

	<p><dfn>Алгоритм Бройдена — Флетчера — Гольдфарба — Шанно (BFGS)</dfn><br>
	— итерационный метод численной оптимизации, предназначенный для<br>
	нахождения локального максимума/минимума нелинейного функционала<br>
	без ограничений.</p>

	<p>Почему именно алгоритм Флетчера, а не другие популярные алгоритмы вроде:
	<ul>
	<li><dfn>CRC16/32</dfn> - алгоритм нахождения контрольной суммы, предназначенный для проверки<br>
	целостности данных</li>
	<li><dfn>md5</dfn> - 128-битный алгоритм хеширования. Предназначен для создания «отпечатков»<br>
	или дайджестов сообщения произвольной длины и последующей проверки<br>
	их подлинности.</li>

	<p>Потому что он быстрый, компактный и легок в реализации.</p>
	<article>
	<h2>Итог</h2>

	<p>Фактически мы экономим 80-90% трафика. Размер загружаемой статитки в байтах:</p>
	<table>
		<thead>
			<tr>
				<th>Релиз</th>
				<th>С патчем</th>
				<th>Без патча</th>
			</tr>
		<tbody>
			<tr>
				<th>7.7.20</th>
				<th>397</th>
				<th>174 549</th>
			</tr>
			<tr>
				<th>7.7.21</th>
				<th>383</th>
				<th>53 995</th>
			</tr>
			<tr>
				<th>7.7.22</th>
				<th>483</th>
				<th>3 995</th>
			</tr>
		</tbody>
		<thead>
	</table>
	</article>

	<p><dt>Автор:</dt> <dd>@doochik</dd></p>
	<p>С++ разработик</p>
	<p><dt>Электронная почта:</dt> <dd>(doochik@yandex-team.ru)</dd></p>
	<p><dt>Компания:</dt> <dd>Яндекс</dd></p>

	<p>Комментарии (3):</p>
	 <p>Mogaika (mogaika@yandex-team.ru) <time>30 ноября 2014 в 17:05</time></p>

	 <p> А можете привести сравнение, на сколько быстрее грузится lite версия?</p>

	<p> JIguse (mrawesome@yandex.ru)<time> 29 ноября 2014 в 21:30</time></p>

	 <p> Спасибо за статью, познавательно. Здорово, что Яндекс делится некоторыми<br>
	  подробностями о внутренней работе сервисов.</p>

	<p> Brister (brist89@yandex-team.ru)<time> 24 ноября 2014 в 13:13</time></p>

	  <p><q><i>(кол-во счастливых пользователей + кол-во удовлетворенных / 2) / (кол-во всех).<br>
	  Получается значение от нуля до единицы, которое, видимо, лучше всего показывает,<br>
	  хорошо или плохо работает почта.</i></q></p>

	  <p>наверное все-таки от 0.5 до 1</li></p>

	<p>alexeimois (test@yandex.ru) <time>22 ноября 2014 в 17:35</time></p>

	  <p>Мы измеряем скорость загрузки с помощью Яндекс.Метрики:</p>
	  <a href=help.yandex.ru/metrika/reports/monitoring_timing.xml>help.yandex.ru/metrika/reports/monitoring_timing.xml</a>
</article>
</article>
<footer>
	<p> © Яндекс, <a href=mailto:help@yandex.ru></a>help@yandex.ru, Хохрякова, 10 </p>
</footer>
</body>
